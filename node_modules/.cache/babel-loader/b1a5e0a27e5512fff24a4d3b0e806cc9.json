{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nimport { Trade } from '@pancakeswap-libs/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useMemo } from 'react';\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants';\nimport { PairState, usePairs } from '../data/Reserves';\nimport { wrappedCurrency } from '../utils/wrappedCurrency';\nimport { useActiveWeb3React } from './index';\n\nfunction useAllCommonPairs(currencyA, currencyB) {\n  _s();\n\n  const {\n    chainId\n  } = useActiveWeb3React(); // Base tokens for building intermediary trading routes\n\n  const bases = useMemo(() => chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : [], [chainId]); // All pairs from base tokens\n\n  const basePairs = useMemo(() => flatMap(bases, base => bases.map(otherBase => [base, otherBase])).filter(([t0, t1]) => t0.address !== t1.address), [bases]);\n  const [tokenA, tokenB] = chainId ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)] : [undefined, undefined];\n  const allPairCombinations = useMemo(() => tokenA && tokenB ? [// the direct pair\n  [tokenA, tokenB], // token A against all bases\n  ...bases.map(base => [tokenA, base]), // token B against all bases\n  ...bases.map(base => [tokenB, base]), // each base against all bases\n  ...basePairs].filter(tokens => Boolean(tokens[0] && tokens[1])).filter(([t0, t1]) => t0.address !== t1.address) // This filter will remove all the pairs that are not supported by the CUSTOM_BASES settings\n  // This option is currently not used on Pancake swap\n  .filter(([t0, t1]) => {\n    if (!chainId) return true;\n    const customBases = CUSTOM_BASES[chainId];\n    if (!customBases) return true;\n    const customBasesA = customBases[t0.address];\n    const customBasesB = customBases[t1.address];\n    if (!customBasesA && !customBasesB) return true;\n    if (customBasesA && !customBasesA.find(base => t1.equals(base))) return false;\n    if (customBasesB && !customBasesB.find(base => t0.equals(base))) return false;\n    return true;\n  }) : [], [tokenA, tokenB, bases, basePairs, chainId]);\n  const allPairs = usePairs(allPairCombinations); // only pass along valid pairs, non-duplicated pairs\n\n  return useMemo(() => Object.values(allPairs // filter out invalid pairs\n  .filter(result => Boolean(result[0] === PairState.EXISTS && result[1])) // filter out duplicated pairs\n  .reduce((memo, [, curr]) => {\n    var _memo$curr$liquidityT;\n\n    memo[curr.liquidityToken.address] = (_memo$curr$liquidityT = memo[curr.liquidityToken.address]) !== null && _memo$curr$liquidityT !== void 0 ? _memo$curr$liquidityT : curr;\n    return memo;\n  }, {})), [allPairs]);\n}\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\n\n\n_s(useAllCommonPairs, \"yOlOGLSe6CG5zU7a8alITxmtf8s=\", false, function () {\n  return [useActiveWeb3React, usePairs];\n});\n\nexport function useTradeExactIn(currencyAmountIn, currencyOut) {\n  _s2();\n\n  const allowedPairs = useAllCommonPairs(currencyAmountIn === null || currencyAmountIn === void 0 ? void 0 : currencyAmountIn.currency, currencyOut);\n  return useMemo(() => {\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact;\n\n      return (_Trade$bestTradeExact = Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact !== void 0 ? _Trade$bestTradeExact : null;\n    }\n\n    return null;\n  }, [allowedPairs, currencyAmountIn, currencyOut]);\n}\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\n\n_s2(useTradeExactIn, \"VKnNShbqc2Xh9bmx09RrKz6CRDo=\", false, function () {\n  return [useAllCommonPairs];\n});\n\nexport function useTradeExactOut(currencyIn, currencyAmountOut) {\n  _s3();\n\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut === null || currencyAmountOut === void 0 ? void 0 : currencyAmountOut.currency);\n  return useMemo(() => {\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\n      var _Trade$bestTradeExact2;\n\n      return (_Trade$bestTradeExact2 = Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, {\n        maxHops: 3,\n        maxNumResults: 1\n      })[0]) !== null && _Trade$bestTradeExact2 !== void 0 ? _Trade$bestTradeExact2 : null;\n    }\n\n    return null;\n  }, [allowedPairs, currencyIn, currencyAmountOut]);\n}\n\n_s3(useTradeExactOut, \"VKnNShbqc2Xh9bmx09RrKz6CRDo=\", false, function () {\n  return [useAllCommonPairs];\n});","map":{"version":3,"sources":["C:/PROYECTOS/CACAO-swap/src/hooks/Trades.ts"],"names":["Trade","flatMap","useMemo","BASES_TO_CHECK_TRADES_AGAINST","CUSTOM_BASES","PairState","usePairs","wrappedCurrency","useActiveWeb3React","useAllCommonPairs","currencyA","currencyB","chainId","bases","basePairs","base","map","otherBase","filter","t0","t1","address","tokenA","tokenB","undefined","allPairCombinations","tokens","Boolean","customBases","customBasesA","customBasesB","find","equals","allPairs","Object","values","result","EXISTS","reduce","memo","curr","liquidityToken","useTradeExactIn","currencyAmountIn","currencyOut","allowedPairs","currency","length","bestTradeExactIn","maxHops","maxNumResults","useTradeExactOut","currencyIn","currencyAmountOut","bestTradeExactOut"],"mappings":"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","sourcesContent":["import { Currency, CurrencyAmount, Pair, Token, Trade } from '@pancakeswap-libs/sdk'\r\nimport flatMap from 'lodash.flatmap'\r\nimport { useMemo } from 'react'\r\n\r\nimport { BASES_TO_CHECK_TRADES_AGAINST, CUSTOM_BASES } from '../constants'\r\nimport { PairState, usePairs } from '../data/Reserves'\r\nimport { wrappedCurrency } from '../utils/wrappedCurrency'\r\n\r\nimport { useActiveWeb3React } from './index'\r\n\r\nfunction useAllCommonPairs(currencyA?: Currency, currencyB?: Currency): Pair[] {\r\n  const { chainId } = useActiveWeb3React()\r\n\r\n  // Base tokens for building intermediary trading routes\r\n  const bases: Token[] = useMemo(() => (chainId ? BASES_TO_CHECK_TRADES_AGAINST[chainId] : []), [chainId])\r\n\r\n  // All pairs from base tokens\r\n  const basePairs: [Token, Token][] = useMemo(\r\n    () =>\r\n      flatMap(bases, (base): [Token, Token][] => bases.map((otherBase) => [base, otherBase])).filter(\r\n        ([t0, t1]) => t0.address !== t1.address\r\n      ),\r\n    [bases]\r\n  )\r\n\r\n  const [tokenA, tokenB] = chainId\r\n    ? [wrappedCurrency(currencyA, chainId), wrappedCurrency(currencyB, chainId)]\r\n    : [undefined, undefined]\r\n\r\n  const allPairCombinations: [Token, Token][] = useMemo(\r\n    () =>\r\n      tokenA && tokenB\r\n        ? [\r\n            // the direct pair\r\n            [tokenA, tokenB],\r\n            // token A against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenA, base]),\r\n            // token B against all bases\r\n            ...bases.map((base): [Token, Token] => [tokenB, base]),\r\n            // each base against all bases\r\n            ...basePairs,\r\n          ]\r\n            .filter((tokens): tokens is [Token, Token] => Boolean(tokens[0] && tokens[1]))\r\n            .filter(([t0, t1]) => t0.address !== t1.address)\r\n            // This filter will remove all the pairs that are not supported by the CUSTOM_BASES settings\r\n            // This option is currently not used on Pancake swap\r\n            .filter(([t0, t1]) => {\r\n              if (!chainId) return true\r\n              const customBases = CUSTOM_BASES[chainId]\r\n              if (!customBases) return true\r\n\r\n              const customBasesA: Token[] | undefined = customBases[t0.address]\r\n              const customBasesB: Token[] | undefined = customBases[t1.address]\r\n\r\n              if (!customBasesA && !customBasesB) return true\r\n              if (customBasesA && !customBasesA.find((base) => t1.equals(base))) return false\r\n              if (customBasesB && !customBasesB.find((base) => t0.equals(base))) return false\r\n\r\n              return true\r\n            })\r\n        : [],\r\n    [tokenA, tokenB, bases, basePairs, chainId]\r\n  )\r\n\r\n  const allPairs = usePairs(allPairCombinations)\r\n\r\n  // only pass along valid pairs, non-duplicated pairs\r\n  return useMemo(\r\n    () =>\r\n      Object.values(\r\n        allPairs\r\n          // filter out invalid pairs\r\n          .filter((result): result is [PairState.EXISTS, Pair] => Boolean(result[0] === PairState.EXISTS && result[1]))\r\n          // filter out duplicated pairs\r\n          .reduce<{ [pairAddress: string]: Pair }>((memo, [, curr]) => {\r\n            memo[curr.liquidityToken.address] = memo[curr.liquidityToken.address] ?? curr\r\n            return memo\r\n          }, {})\r\n      ),\r\n    [allPairs]\r\n  )\r\n}\r\n\r\n/**\r\n * Returns the best trade for the exact amount of tokens in to the given token out\r\n */\r\nexport function useTradeExactIn(currencyAmountIn?: CurrencyAmount, currencyOut?: Currency): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyAmountIn?.currency, currencyOut)\r\n\r\n  return useMemo(() => {\r\n    if (currencyAmountIn && currencyOut && allowedPairs.length > 0) {\r\n      return (\r\n        Trade.bestTradeExactIn(allowedPairs, currencyAmountIn, currencyOut, { maxHops: 3, maxNumResults: 1 })[0] ?? null\r\n      )\r\n    }\r\n    return null\r\n  }, [allowedPairs, currencyAmountIn, currencyOut])\r\n}\r\n\r\n/**\r\n * Returns the best trade for the token in to the exact amount of token out\r\n */\r\nexport function useTradeExactOut(currencyIn?: Currency, currencyAmountOut?: CurrencyAmount): Trade | null {\r\n  const allowedPairs = useAllCommonPairs(currencyIn, currencyAmountOut?.currency)\r\n\r\n  return useMemo(() => {\r\n    if (currencyIn && currencyAmountOut && allowedPairs.length > 0) {\r\n      return (\r\n        Trade.bestTradeExactOut(allowedPairs, currencyIn, currencyAmountOut, { maxHops: 3, maxNumResults: 1 })[0] ??\r\n        null\r\n      )\r\n    }\r\n    return null\r\n  }, [allowedPairs, currencyIn, currencyAmountOut])\r\n}\r\n"]},"metadata":{},"sourceType":"module"}